###################
How to use the Core
###################

The Entando framework core is based on three main components:
``entando-engine``, ``entando admin-console``, ``entando portal-ui``.

They are essential elements of the framework since provide the useful
functionality to realize customized services.

Their high-level description and the interaction process is summarized
in the `How It
Works <https://github.com/entando/entando-core/wiki/How-It-Works>`__
page. More specifically, it shows how the *admin-console* component
interacts with the *engine* component to expose various services and how
the *portal-ui* interacts with *admin-console* and *engine* in order to
provide the requested services to the final users.

In this page the procedure for using the three components useful to
create a web application is described:

-  How to use the main services exposed by the *engine* component;
-  How to sue the main functionality provided by the *admin-console*
   component in order to create back-office interfaces;
-  How to use the main functionality and tools provided by the
   *portal-ui* component to create the basic elements for front-end
   interfaces.

--------------

entando-engine
--------------

It is imported as dependency from the archetype and exposes services
which are accessed in two ways:

**1) Spring Dependency Injection**

Configuring the xml of the bean we are creating in order to use the
entando-engine services

.. code:: xml

    <?xml version="1.0" encoding="UTF-8"?>
    <beans xmlns="http://www.springframework.org/schema/beans"
            xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
            xmlns:context="http://www.springframework.org/schema/context"
            xmlns:jee="http://www.springframework.org/schema/jee"
            xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd
                    http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd
                    http://www.springframework.org/schema/jee http://www.springframework.org/schema/jee/spring-jee-4.0.xsd" >

        <bean id="myBean" class="com.my.package.Class” parent="abstractService">
            <property name="userProfileManager" ref="UserProfileManager" />
        </bean>
    </beans>

For further details on how to use the dependency injection see the
`Spring documentation
website <http://docs.spring.io/spring/docs/4.0.6.RELEASE/spring-framework-reference/html/>`__.

**2) Application Context**

Access the bean of the manager using ``ApsWebApplicationUtils.getBean``

.. code:: java

    import com.agiletec.aps.util.ApsWebApplicationUtils;

    //...

    IAuthorizationManager entandoAuthManager = (IAuthorizationManager) ApsWebApplicationUtils.getBean(SystemConstants.AUTHORIZATION_SERVICE, this.pageContext);

    //do something with entandoAuthManager...

--------------

Entando admin-console
---------------------

The developer will use the services exposed from the entando
admin-console for managing objects and data for the web application's
administrators (back-office)

-  struts2 infrastructure (interceptors stack, helpers, base actions…)
-  back-office templating system
-  front-end templating system
-  back-office tag libraries
-  activity stream
-  back-office user shortcuts

Entando admin-console provides all those functionalities needed to
manage the applications (widgets, page models and pages) which portal-ui
component will use, keep reading the Entando portal-ui.

--------------

Entando portal-ui
-----------------

It provides the tools needed to create the front-end part of the web
application. The three main elements are:

-  Page
-  Widget
-  Content

Pages
~~~~~

Users access the web application through the Entando Pages which are
organized in a tree. Portal-ui gives the tools to create, edit and
delete the pages and the page tree.

Pages are created using models. Page Models define the structure of the
page and tell the system what are the configurable slot available for
that page and provide also a template for the GUI Page Models can be
managed drom the back-office.

Example of a Page Tree:

-  Home (Page Model Two Columns)

   -  About Us (Page Model Two Columns)

      -  Contact Us (Page Model Three Columns Green)

   -  Buy (Page Model Two Columns)

-  Pricing (Page Model Three Columns Green)

   -  Shipment (Page Model Three Columns Red)

Page Models Xml The xml describes what configurable slots will be
supported by the page Example of an XML:

.. code:: js

    <?xml version="1.0" encoding="UTF-8"?>
    <frames>
        <frame pos="0">
            <descr>Header</descr>
        </frame>
        <frame pos="1">
            <descr>Body</descr>
        </frame>
        <frame pos="2">
            <descr>Footer</descr>
        </frame>
    </frames>

There will be possible to add any number of <frame> elements with the
only constraint that the pos attributes are numbered correctly. The
<descr> element contains the description visible in the back-office, it
will show up to the administrator when performing actions with the
pages.

Page Models Template They are the template UI of the page and it’s
written in Freemarker language and with the Entando front-end tag
library will be possible to recall the positions content.

Here a template example working with the previous example xml:

.. code:: html

    <#assign wp=JspTaglibs["/aps-core"]>
    <!DOCTYPE html>
    <html lang="<@wp.info key=”currentLang” />">
        <head>
            <title><@wp.currentPage param="title" /></title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <meta http-equiv="X-UA-Compatible" content="IE=edge">
            <link rel="stylesheet" type="text/css" href="<@wp.cssUrl />pagemodes/mycss.css">
        </head>
        <body>
            <div id="header"><@wp.show frame="0" /></div>
            <div id="body"><@wp.show frame="1" /></div>
            <div id="footer"><@wp.show frame="2" /></div>
        </body>
    </html>

Widgets
~~~~~~~

Widgets are the bricks that make up the web application. Since version
4.2 is possible to create new widget from the web back-office.

Developers should know in order to add new widget that a new record in
the widgetcatalog table of the port database must be created.

.. code:: sql

    INSERT INTO widgetcatalog ( code,titles,parameters,plugincode,parenttypecode,defaultconfig,locked,maingroup )
    VALUES (
        'mywidget',
        '<?xml version="1.0" encoding="UTF-8"?>
                <properties>
                <property key="en">System Messages</property>
                <property key="it">Messaggi di Sistema</property>
        </properties>',
        '<config>
            <parameter name="myParamName">
                My Param Description
            </parameter>
            <action name="configSimpleParameter"/>
        </config>',
        NULL, NULL, NULL, 1, NULL);

Since version 4.2 widgets are rendered using the *Entando Fragments*,
which are a piece of Freemarker template giving html as output, html
that will be concatenated in Pages. This means that for every widget
there is a Fragment making its GUI.

These Entando Fragments can be managed form the back-office. Here an
example of the gui code for a widget returning the value of a parameter:

.. code:: html+velocity

    <#assign wp=JspTaglibs["/aps-core"]>
    Stored value for myParamName is: <@wp.currentWidget param="config" configParam="myParamName" />

Contents
~~~~~~~~

Within the default distribution of Entando *portal-ui* is embedded the
CMS plugin, it allows the management of the contents.

From the back-office is possible to manage the content archive and with
dedicated widgets is possible to publish lists or single contents.

Content from the CMS are grouped by Content Types. Think of each Content
Type as the proprotype describing the content structure. For instance,
the application can have the Content Type News, Announcement, Event,
Contact… according to the needs more Content Types, this allows to:

-  content archive cataloged homogeneously
-  easier editing because every field is strictly related to that type
-  ui customization with specific templates for each type

More in detail, Content Types structure the contents using basic data
type such as texts, numbers, hypertexts, dates and few others.

Example, Content Type News:

-  *Title* -> multilingual text
-  *Publication Date* -> date
-  *Subtitle* -> multilingual long text
-  *Body* -> multilingual hypertext
-  *Main Picture* -> image
-  *Secondary Picture* -> image

With a so defined structure will be easy to introduce the validation
check (mandatory fields, length) needed and also will be possible to
publish widget with automatic generated lists filtering and sorting
using those attributes (i.e. sort by title ascending, then date
descending and with date greater than today…).
